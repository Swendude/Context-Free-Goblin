-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Grammar.InputObject exposing (..)

import Grammar.Enum.Grammars_constraint
import Grammar.Enum.Grammars_update_column
import Grammar.Enum.Order_by
import Grammar.Interface
import Grammar.Object
import Grammar.Scalar
import Grammar.ScalarCodecs
import Grammar.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildGrammars_aggregate_order_by : (Grammars_aggregate_order_byOptionalFields -> Grammars_aggregate_order_byOptionalFields) -> Grammars_aggregate_order_by
buildGrammars_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias Grammars_aggregate_order_byOptionalFields =
    { count : OptionalArgument Grammar.Enum.Order_by.Order_by
    , max : OptionalArgument Grammars_max_order_by
    , min : OptionalArgument Grammars_min_order_by
    }


{-| Type for the Grammars\_aggregate\_order\_by input object.
-}
type alias Grammars_aggregate_order_by =
    { count : OptionalArgument Grammar.Enum.Order_by.Order_by
    , max : OptionalArgument Grammars_max_order_by
    , min : OptionalArgument Grammars_min_order_by
    }


{-| Encode a Grammars\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeGrammars_aggregate_order_by : Grammars_aggregate_order_by -> Value
encodeGrammars_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeGrammars_max_order_by |> Encode.optional input.max ), ( "min", encodeGrammars_min_order_by |> Encode.optional input.min ) ]


buildGrammars_append_input : (Grammars_append_inputOptionalFields -> Grammars_append_inputOptionalFields) -> Grammars_append_input
buildGrammars_append_input fillOptionals =
    let
        optionals =
            fillOptionals
                { grammar = Absent }
    in
    { grammar = optionals.grammar }


type alias Grammars_append_inputOptionalFields =
    { grammar : OptionalArgument Grammar.ScalarCodecs.Jsonb }


{-| Type for the Grammars\_append\_input input object.
-}
type alias Grammars_append_input =
    { grammar : OptionalArgument Grammar.ScalarCodecs.Jsonb }


{-| Encode a Grammars\_append\_input into a value that can be used as an argument.
-}
encodeGrammars_append_input : Grammars_append_input -> Value
encodeGrammars_append_input input =
    Encode.maybeObject
        [ ( "grammar", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.grammar ) ]


buildGrammars_arr_rel_insert_input : Grammars_arr_rel_insert_inputRequiredFields -> (Grammars_arr_rel_insert_inputOptionalFields -> Grammars_arr_rel_insert_inputOptionalFields) -> Grammars_arr_rel_insert_input
buildGrammars_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Grammars_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Grammars_arr_rel_insert_inputRequiredFields =
    { data : List Grammars_insert_input }


type alias Grammars_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Grammars_on_conflict }


{-| Type alias for the `Grammars_arr_rel_insert_input` attributes. Note that this type
needs to use the `Grammars_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Grammars_arr_rel_insert_inputRaw =
    { data : List Grammars_insert_input
    , on_conflict : OptionalArgument Grammars_on_conflict
    }


{-| Type for the Grammars\_arr\_rel\_insert\_input input object.
-}
type Grammars_arr_rel_insert_input
    = Grammars_arr_rel_insert_input Grammars_arr_rel_insert_inputRaw


{-| Encode a Grammars\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeGrammars_arr_rel_insert_input : Grammars_arr_rel_insert_input -> Value
encodeGrammars_arr_rel_insert_input (Grammars_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeGrammars_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeGrammars_on_conflict |> Encode.optional input.on_conflict ) ]


buildGrammars_bool_exp : (Grammars_bool_expOptionalFields -> Grammars_bool_expOptionalFields) -> Grammars_bool_exp
buildGrammars_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, desciption = Absent, grammar = Absent, grammar_parent = Absent, id = Absent, name = Absent, parent = Absent }
    in
    Grammars_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, desciption = optionals.desciption, grammar = optionals.grammar, grammar_parent = optionals.grammar_parent, id = optionals.id, name = optionals.name, parent = optionals.parent }


type alias Grammars_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Grammars_bool_exp))
    , not_ : OptionalArgument Grammars_bool_exp
    , or_ : OptionalArgument (List (Maybe Grammars_bool_exp))
    , desciption : OptionalArgument String_comparison_exp
    , grammar : OptionalArgument Jsonb_comparison_exp
    , grammar_parent : OptionalArgument Grammars_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , parent : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Grammars_bool_exp` attributes. Note that this type
needs to use the `Grammars_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Grammars_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Grammars_bool_exp))
    , not_ : OptionalArgument Grammars_bool_exp
    , or_ : OptionalArgument (List (Maybe Grammars_bool_exp))
    , desciption : OptionalArgument String_comparison_exp
    , grammar : OptionalArgument Jsonb_comparison_exp
    , grammar_parent : OptionalArgument Grammars_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , parent : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Grammars\_bool\_exp input object.
-}
type Grammars_bool_exp
    = Grammars_bool_exp Grammars_bool_expRaw


{-| Encode a Grammars\_bool\_exp into a value that can be used as an argument.
-}
encodeGrammars_bool_exp : Grammars_bool_exp -> Value
encodeGrammars_bool_exp (Grammars_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeGrammars_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeGrammars_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeGrammars_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "desciption", encodeString_comparison_exp |> Encode.optional input.desciption ), ( "grammar", encodeJsonb_comparison_exp |> Encode.optional input.grammar ), ( "grammar_parent", encodeGrammars_bool_exp |> Encode.optional input.grammar_parent ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "name", encodeString_comparison_exp |> Encode.optional input.name ), ( "parent", encodeUuid_comparison_exp |> Encode.optional input.parent ) ]


buildGrammars_delete_at_path_input : (Grammars_delete_at_path_inputOptionalFields -> Grammars_delete_at_path_inputOptionalFields) -> Grammars_delete_at_path_input
buildGrammars_delete_at_path_input fillOptionals =
    let
        optionals =
            fillOptionals
                { grammar = Absent }
    in
    { grammar = optionals.grammar }


type alias Grammars_delete_at_path_inputOptionalFields =
    { grammar : OptionalArgument (List (Maybe String)) }


{-| Type for the Grammars\_delete\_at\_path\_input input object.
-}
type alias Grammars_delete_at_path_input =
    { grammar : OptionalArgument (List (Maybe String)) }


{-| Encode a Grammars\_delete\_at\_path\_input into a value that can be used as an argument.
-}
encodeGrammars_delete_at_path_input : Grammars_delete_at_path_input -> Value
encodeGrammars_delete_at_path_input input =
    Encode.maybeObject
        [ ( "grammar", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.grammar ) ]


buildGrammars_delete_elem_input : (Grammars_delete_elem_inputOptionalFields -> Grammars_delete_elem_inputOptionalFields) -> Grammars_delete_elem_input
buildGrammars_delete_elem_input fillOptionals =
    let
        optionals =
            fillOptionals
                { grammar = Absent }
    in
    { grammar = optionals.grammar }


type alias Grammars_delete_elem_inputOptionalFields =
    { grammar : OptionalArgument Int }


{-| Type for the Grammars\_delete\_elem\_input input object.
-}
type alias Grammars_delete_elem_input =
    { grammar : OptionalArgument Int }


{-| Encode a Grammars\_delete\_elem\_input into a value that can be used as an argument.
-}
encodeGrammars_delete_elem_input : Grammars_delete_elem_input -> Value
encodeGrammars_delete_elem_input input =
    Encode.maybeObject
        [ ( "grammar", Encode.int |> Encode.optional input.grammar ) ]


buildGrammars_delete_key_input : (Grammars_delete_key_inputOptionalFields -> Grammars_delete_key_inputOptionalFields) -> Grammars_delete_key_input
buildGrammars_delete_key_input fillOptionals =
    let
        optionals =
            fillOptionals
                { grammar = Absent }
    in
    { grammar = optionals.grammar }


type alias Grammars_delete_key_inputOptionalFields =
    { grammar : OptionalArgument String }


{-| Type for the Grammars\_delete\_key\_input input object.
-}
type alias Grammars_delete_key_input =
    { grammar : OptionalArgument String }


{-| Encode a Grammars\_delete\_key\_input into a value that can be used as an argument.
-}
encodeGrammars_delete_key_input : Grammars_delete_key_input -> Value
encodeGrammars_delete_key_input input =
    Encode.maybeObject
        [ ( "grammar", Encode.string |> Encode.optional input.grammar ) ]


buildGrammars_insert_input : (Grammars_insert_inputOptionalFields -> Grammars_insert_inputOptionalFields) -> Grammars_insert_input
buildGrammars_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { desciption = Absent, grammar = Absent, grammar_parent = Absent, id = Absent, name = Absent, parent = Absent }
    in
    Grammars_insert_input { desciption = optionals.desciption, grammar = optionals.grammar, grammar_parent = optionals.grammar_parent, id = optionals.id, name = optionals.name, parent = optionals.parent }


type alias Grammars_insert_inputOptionalFields =
    { desciption : OptionalArgument String
    , grammar : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , grammar_parent : OptionalArgument Grammars_obj_rel_insert_input
    , id : OptionalArgument Grammar.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , parent : OptionalArgument Grammar.ScalarCodecs.Uuid
    }


{-| Type alias for the `Grammars_insert_input` attributes. Note that this type
needs to use the `Grammars_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Grammars_insert_inputRaw =
    { desciption : OptionalArgument String
    , grammar : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , grammar_parent : OptionalArgument Grammars_obj_rel_insert_input
    , id : OptionalArgument Grammar.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , parent : OptionalArgument Grammar.ScalarCodecs.Uuid
    }


{-| Type for the Grammars\_insert\_input input object.
-}
type Grammars_insert_input
    = Grammars_insert_input Grammars_insert_inputRaw


{-| Encode a Grammars\_insert\_input into a value that can be used as an argument.
-}
encodeGrammars_insert_input : Grammars_insert_input -> Value
encodeGrammars_insert_input (Grammars_insert_input input) =
    Encode.maybeObject
        [ ( "desciption", Encode.string |> Encode.optional input.desciption ), ( "grammar", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.grammar ), ( "grammar_parent", encodeGrammars_obj_rel_insert_input |> Encode.optional input.grammar_parent ), ( "id", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "parent", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.parent ) ]


buildGrammars_max_order_by : (Grammars_max_order_byOptionalFields -> Grammars_max_order_byOptionalFields) -> Grammars_max_order_by
buildGrammars_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { desciption = Absent, name = Absent }
    in
    { desciption = optionals.desciption, name = optionals.name }


type alias Grammars_max_order_byOptionalFields =
    { desciption : OptionalArgument Grammar.Enum.Order_by.Order_by
    , name : OptionalArgument Grammar.Enum.Order_by.Order_by
    }


{-| Type for the Grammars\_max\_order\_by input object.
-}
type alias Grammars_max_order_by =
    { desciption : OptionalArgument Grammar.Enum.Order_by.Order_by
    , name : OptionalArgument Grammar.Enum.Order_by.Order_by
    }


{-| Encode a Grammars\_max\_order\_by into a value that can be used as an argument.
-}
encodeGrammars_max_order_by : Grammars_max_order_by -> Value
encodeGrammars_max_order_by input =
    Encode.maybeObject
        [ ( "desciption", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.desciption ), ( "name", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildGrammars_min_order_by : (Grammars_min_order_byOptionalFields -> Grammars_min_order_byOptionalFields) -> Grammars_min_order_by
buildGrammars_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { desciption = Absent, name = Absent }
    in
    { desciption = optionals.desciption, name = optionals.name }


type alias Grammars_min_order_byOptionalFields =
    { desciption : OptionalArgument Grammar.Enum.Order_by.Order_by
    , name : OptionalArgument Grammar.Enum.Order_by.Order_by
    }


{-| Type for the Grammars\_min\_order\_by input object.
-}
type alias Grammars_min_order_by =
    { desciption : OptionalArgument Grammar.Enum.Order_by.Order_by
    , name : OptionalArgument Grammar.Enum.Order_by.Order_by
    }


{-| Encode a Grammars\_min\_order\_by into a value that can be used as an argument.
-}
encodeGrammars_min_order_by : Grammars_min_order_by -> Value
encodeGrammars_min_order_by input =
    Encode.maybeObject
        [ ( "desciption", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.desciption ), ( "name", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildGrammars_obj_rel_insert_input : Grammars_obj_rel_insert_inputRequiredFields -> (Grammars_obj_rel_insert_inputOptionalFields -> Grammars_obj_rel_insert_inputOptionalFields) -> Grammars_obj_rel_insert_input
buildGrammars_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Grammars_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Grammars_obj_rel_insert_inputRequiredFields =
    { data : Grammars_insert_input }


type alias Grammars_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Grammars_on_conflict }


{-| Type alias for the `Grammars_obj_rel_insert_input` attributes. Note that this type
needs to use the `Grammars_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Grammars_obj_rel_insert_inputRaw =
    { data : Grammars_insert_input
    , on_conflict : OptionalArgument Grammars_on_conflict
    }


{-| Type for the Grammars\_obj\_rel\_insert\_input input object.
-}
type Grammars_obj_rel_insert_input
    = Grammars_obj_rel_insert_input Grammars_obj_rel_insert_inputRaw


{-| Encode a Grammars\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeGrammars_obj_rel_insert_input : Grammars_obj_rel_insert_input -> Value
encodeGrammars_obj_rel_insert_input (Grammars_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeGrammars_insert_input input.data |> Just ), ( "on_conflict", encodeGrammars_on_conflict |> Encode.optional input.on_conflict ) ]


buildGrammars_on_conflict : Grammars_on_conflictRequiredFields -> (Grammars_on_conflictOptionalFields -> Grammars_on_conflictOptionalFields) -> Grammars_on_conflict
buildGrammars_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Grammars_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Grammars_on_conflictRequiredFields =
    { constraint : Grammar.Enum.Grammars_constraint.Grammars_constraint
    , update_columns : List Grammar.Enum.Grammars_update_column.Grammars_update_column
    }


type alias Grammars_on_conflictOptionalFields =
    { where_ : OptionalArgument Grammars_bool_exp }


{-| Type alias for the `Grammars_on_conflict` attributes. Note that this type
needs to use the `Grammars_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Grammars_on_conflictRaw =
    { constraint : Grammar.Enum.Grammars_constraint.Grammars_constraint
    , update_columns : List Grammar.Enum.Grammars_update_column.Grammars_update_column
    , where_ : OptionalArgument Grammars_bool_exp
    }


{-| Type for the Grammars\_on\_conflict input object.
-}
type Grammars_on_conflict
    = Grammars_on_conflict Grammars_on_conflictRaw


{-| Encode a Grammars\_on\_conflict into a value that can be used as an argument.
-}
encodeGrammars_on_conflict : Grammars_on_conflict -> Value
encodeGrammars_on_conflict (Grammars_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Grammar.Enum.Grammars_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Grammar.Enum.Grammars_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeGrammars_bool_exp |> Encode.optional input.where_ ) ]


buildGrammars_order_by : (Grammars_order_byOptionalFields -> Grammars_order_byOptionalFields) -> Grammars_order_by
buildGrammars_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { desciption = Absent, grammar = Absent, grammar_parent = Absent, id = Absent, name = Absent, parent = Absent }
    in
    Grammars_order_by { desciption = optionals.desciption, grammar = optionals.grammar, grammar_parent = optionals.grammar_parent, id = optionals.id, name = optionals.name, parent = optionals.parent }


type alias Grammars_order_byOptionalFields =
    { desciption : OptionalArgument Grammar.Enum.Order_by.Order_by
    , grammar : OptionalArgument Grammar.Enum.Order_by.Order_by
    , grammar_parent : OptionalArgument Grammars_order_by
    , id : OptionalArgument Grammar.Enum.Order_by.Order_by
    , name : OptionalArgument Grammar.Enum.Order_by.Order_by
    , parent : OptionalArgument Grammar.Enum.Order_by.Order_by
    }


{-| Type alias for the `Grammars_order_by` attributes. Note that this type
needs to use the `Grammars_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Grammars_order_byRaw =
    { desciption : OptionalArgument Grammar.Enum.Order_by.Order_by
    , grammar : OptionalArgument Grammar.Enum.Order_by.Order_by
    , grammar_parent : OptionalArgument Grammars_order_by
    , id : OptionalArgument Grammar.Enum.Order_by.Order_by
    , name : OptionalArgument Grammar.Enum.Order_by.Order_by
    , parent : OptionalArgument Grammar.Enum.Order_by.Order_by
    }


{-| Type for the Grammars\_order\_by input object.
-}
type Grammars_order_by
    = Grammars_order_by Grammars_order_byRaw


{-| Encode a Grammars\_order\_by into a value that can be used as an argument.
-}
encodeGrammars_order_by : Grammars_order_by -> Value
encodeGrammars_order_by (Grammars_order_by input) =
    Encode.maybeObject
        [ ( "desciption", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.desciption ), ( "grammar", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.grammar ), ( "grammar_parent", encodeGrammars_order_by |> Encode.optional input.grammar_parent ), ( "id", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.name ), ( "parent", Encode.enum Grammar.Enum.Order_by.toString |> Encode.optional input.parent ) ]


buildGrammars_prepend_input : (Grammars_prepend_inputOptionalFields -> Grammars_prepend_inputOptionalFields) -> Grammars_prepend_input
buildGrammars_prepend_input fillOptionals =
    let
        optionals =
            fillOptionals
                { grammar = Absent }
    in
    { grammar = optionals.grammar }


type alias Grammars_prepend_inputOptionalFields =
    { grammar : OptionalArgument Grammar.ScalarCodecs.Jsonb }


{-| Type for the Grammars\_prepend\_input input object.
-}
type alias Grammars_prepend_input =
    { grammar : OptionalArgument Grammar.ScalarCodecs.Jsonb }


{-| Encode a Grammars\_prepend\_input into a value that can be used as an argument.
-}
encodeGrammars_prepend_input : Grammars_prepend_input -> Value
encodeGrammars_prepend_input input =
    Encode.maybeObject
        [ ( "grammar", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.grammar ) ]


buildGrammars_set_input : (Grammars_set_inputOptionalFields -> Grammars_set_inputOptionalFields) -> Grammars_set_input
buildGrammars_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { desciption = Absent, grammar = Absent, id = Absent, name = Absent, parent = Absent }
    in
    { desciption = optionals.desciption, grammar = optionals.grammar, id = optionals.id, name = optionals.name, parent = optionals.parent }


type alias Grammars_set_inputOptionalFields =
    { desciption : OptionalArgument String
    , grammar : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , id : OptionalArgument Grammar.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , parent : OptionalArgument Grammar.ScalarCodecs.Uuid
    }


{-| Type for the Grammars\_set\_input input object.
-}
type alias Grammars_set_input =
    { desciption : OptionalArgument String
    , grammar : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , id : OptionalArgument Grammar.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , parent : OptionalArgument Grammar.ScalarCodecs.Uuid
    }


{-| Encode a Grammars\_set\_input into a value that can be used as an argument.
-}
encodeGrammars_set_input : Grammars_set_input -> Value
encodeGrammars_set_input input =
    Encode.maybeObject
        [ ( "desciption", Encode.string |> Encode.optional input.desciption ), ( "grammar", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.grammar ), ( "id", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "parent", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.parent ) ]


buildJsonb_comparison_exp : (Jsonb_comparison_expOptionalFields -> Jsonb_comparison_expOptionalFields) -> Jsonb_comparison_exp
buildJsonb_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { contained_in_ = Absent, contains_ = Absent, eq_ = Absent, gt_ = Absent, gte_ = Absent, has_key_ = Absent, has_keys_all_ = Absent, has_keys_any_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { contained_in_ = optionals.contained_in_, contains_ = optionals.contains_, eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, has_key_ = optionals.has_key_, has_keys_all_ = optionals.has_keys_all_, has_keys_any_ = optionals.has_keys_any_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Jsonb_comparison_expOptionalFields =
    { contained_in_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , contains_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , eq_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , gt_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , gte_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , has_key_ : OptionalArgument String
    , has_keys_all_ : OptionalArgument (List String)
    , has_keys_any_ : OptionalArgument (List String)
    , in_ : OptionalArgument (List Grammar.ScalarCodecs.Jsonb)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , lte_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , neq_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , nin_ : OptionalArgument (List Grammar.ScalarCodecs.Jsonb)
    }


{-| Type for the Jsonb\_comparison\_exp input object.
-}
type alias Jsonb_comparison_exp =
    { contained_in_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , contains_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , eq_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , gt_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , gte_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , has_key_ : OptionalArgument String
    , has_keys_all_ : OptionalArgument (List String)
    , has_keys_any_ : OptionalArgument (List String)
    , in_ : OptionalArgument (List Grammar.ScalarCodecs.Jsonb)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , lte_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , neq_ : OptionalArgument Grammar.ScalarCodecs.Jsonb
    , nin_ : OptionalArgument (List Grammar.ScalarCodecs.Jsonb)
    }


{-| Encode a Jsonb\_comparison\_exp into a value that can be used as an argument.
-}
encodeJsonb_comparison_exp : Jsonb_comparison_exp -> Value
encodeJsonb_comparison_exp input =
    Encode.maybeObject
        [ ( "_contained_in", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.contained_in_ ), ( "_contains", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.contains_ ), ( "_eq", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.eq_ ), ( "_gt", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.gt_ ), ( "_gte", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.gte_ ), ( "_has_key", Encode.string |> Encode.optional input.has_key_ ), ( "_has_keys_all", (Encode.string |> Encode.list) |> Encode.optional input.has_keys_all_ ), ( "_has_keys_any", (Encode.string |> Encode.list) |> Encode.optional input.has_keys_any_ ), ( "_in", ((Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.lt_ ), ( "_lte", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.lte_ ), ( "_neq", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.neq_ ), ( "_nin", ((Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecJsonb) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildUuid_comparison_exp : (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields) -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , gt_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , gte_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , in_ : OptionalArgument (List Grammar.ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , lte_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , neq_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List Grammar.ScalarCodecs.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , gt_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , gte_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , in_ : OptionalArgument (List Grammar.ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , lte_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , neq_ : OptionalArgument Grammar.ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List Grammar.ScalarCodecs.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.eq_ ), ( "_gt", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gt_ ), ( "_gte", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gte_ ), ( "_in", ((Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lt_ ), ( "_lte", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lte_ ), ( "_neq", (Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.neq_ ), ( "_nin", ((Grammar.ScalarCodecs.codecs |> Grammar.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.nin_ ) ]
