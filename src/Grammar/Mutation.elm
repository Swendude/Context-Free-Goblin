-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Grammar.Mutation exposing (..)

import Grammar.InputObject
import Grammar.Interface
import Grammar.Object
import Grammar.Scalar
import Grammar.ScalarCodecs
import Grammar.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias DeleteGrammarsRequiredArguments =
    { where_ : Grammar.InputObject.Grammars_bool_exp }


{-| delete data from the table: "grammars"

  - where\_ - filter the rows which have to be deleted

-}
delete_grammars : DeleteGrammarsRequiredArguments -> SelectionSet decodesTo Grammar.Object.Grammars_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_grammars requiredArgs object_ =
    Object.selectionForCompositeField "delete_grammars" [ Argument.required "where" requiredArgs.where_ Grammar.InputObject.encodeGrammars_bool_exp ] object_ (identity >> Decode.nullable)


type alias InsertGrammarsOptionalArguments =
    { on_conflict : OptionalArgument Grammar.InputObject.Grammars_on_conflict }


type alias InsertGrammarsRequiredArguments =
    { objects : List Grammar.InputObject.Grammars_insert_input }


{-| insert data into the table: "grammars"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_grammars : (InsertGrammarsOptionalArguments -> InsertGrammarsOptionalArguments) -> InsertGrammarsRequiredArguments -> SelectionSet decodesTo Grammar.Object.Grammars_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_grammars fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Grammar.InputObject.encodeGrammars_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_grammars" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Grammar.InputObject.encodeGrammars_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias UpdateGrammarsOptionalArguments =
    { append_ : OptionalArgument Grammar.InputObject.Grammars_append_input
    , delete_at_path_ : OptionalArgument Grammar.InputObject.Grammars_delete_at_path_input
    , delete_elem_ : OptionalArgument Grammar.InputObject.Grammars_delete_elem_input
    , delete_key_ : OptionalArgument Grammar.InputObject.Grammars_delete_key_input
    , prepend_ : OptionalArgument Grammar.InputObject.Grammars_prepend_input
    , set_ : OptionalArgument Grammar.InputObject.Grammars_set_input
    }


type alias UpdateGrammarsRequiredArguments =
    { where_ : Grammar.InputObject.Grammars_bool_exp }


{-| update data of the table: "grammars"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_grammars : (UpdateGrammarsOptionalArguments -> UpdateGrammarsOptionalArguments) -> UpdateGrammarsRequiredArguments -> SelectionSet decodesTo Grammar.Object.Grammars_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_grammars fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_append" filledInOptionals.append_ Grammar.InputObject.encodeGrammars_append_input, Argument.optional "_delete_at_path" filledInOptionals.delete_at_path_ Grammar.InputObject.encodeGrammars_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals.delete_elem_ Grammar.InputObject.encodeGrammars_delete_elem_input, Argument.optional "_delete_key" filledInOptionals.delete_key_ Grammar.InputObject.encodeGrammars_delete_key_input, Argument.optional "_prepend" filledInOptionals.prepend_ Grammar.InputObject.encodeGrammars_prepend_input, Argument.optional "_set" filledInOptionals.set_ Grammar.InputObject.encodeGrammars_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_grammars" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Grammar.InputObject.encodeGrammars_bool_exp ]) object_ (identity >> Decode.nullable)
